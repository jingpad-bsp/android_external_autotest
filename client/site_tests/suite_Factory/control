# -*- coding: utf-8 -*-
#
# Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

AUTHOR = "Chrome OS Team"
NAME = "Factory"
TIME = "LONG"
TEST_CATEGORY = "Functional"
TEST_CLASS = "suite"
TEST_TYPE = "client"

DOC = """
This suite executed all of the factory tests, and incorporates an
X-windows GTK-based UI to highlight testing results and to allow
factory operators to switch between tests, and to re-run tests, all
on-demand via keyboard shortcuts.

The UI is implemented as a seperate process (see _FACTORY_UI_PATH),
which means that interprocess communication is needed between this
control, the UI, and the tests (which are forked children of this
control process).  """


import imp
import os

imp.load_source('common', job.autodir + '/bin/common.py')

from autotest_lib.client.bin import factory
from autotest_lib.client.bin import parallel


FACTORY_UI_PATH = job.autodir + '/bin/factory_ui'
STATUS_FILE_PATH = job.autodir + '/results/default/status'
TEST_LIST_PATH = job.autodir + '/site_tests/suite_Factory/test_list'


# Hack to grab the pid for forked tests.

from autotest_lib.client.bin.parallel import fork_waitfor as orig_fork_waitfor

def new_fork_waitfor(tmp, pid):
    factory.log_shared_data('active_test_data', (tmp, pid))
    orig_fork_waitfor(tmp, pid)

parallel.fork_waitfor = new_fork_waitfor


# These definitions are expose these classes directly into this
# namespace, so that the following exec'ed file can have cleaner
# syntax.  These are done in this fashion, as opposed to "from factory
# import <class>" to work-around Python namespace wackiness -- the
# from syntax does not work, creating new classes.
OperatorTest = factory.OperatorTest
InformationScreen = factory.InformationScreen
AutomatedSequence = factory.AutomatedSequence
AutomatedSubTest = factory.AutomatedSubTest
AutomatedRebootSubTest = factory.AutomatedRebootSubTest


# This exec defines TEST_LIST in global scope.
execfile(TEST_LIST_PATH)


# Hack to work around autotest's obsession with GRUB.
job.bootloader.set_default = lambda x: None
job.bootloader.boot_once = lambda x: None


def start_ui():
  ui_proc_args = [FACTORY_UI_PATH, TEST_LIST_PATH,
                  STATUS_FILE_PATH, str(os.getpid())]
  factory.log('starting ui -- %s' % repr(ui_proc_args))
  sp = subprocess.Popen(ui_proc_args, stdout=subprocess.PIPE)
  factory.log('waiting for ui to come up...')
  factory.log('got message from UI : %s' % repr(sp.stdout.readline().strip()))


def step_reboot_seq(tag_prefix, total_iterations, i=0):
    if i < total_iterations:
        job.next_step_prepend([step_reboot_seq, tag_prefix,
                               total_iterations, i + 1])
        factory.log('rebooting (iteration %d of %d)' % (i, total_iterations))
        job.reboot()
    else:
        step_init(intentional_reboot_subtest_tag_prefix=tag_prefix)


def step_init(intentional_reboot_subtest_tag_prefix=None):
    job.next_step([step_init])

    start_ui()

    status_map = factory.StatusMap(TEST_LIST, STATUS_FILE_PATH)
    control_state = factory.ControlState(
        job, TEST_LIST, status_map, STATUS_FILE_PATH,
        parallel.fork_nuke_subprocess)

    if intentional_reboot_subtest_tag_prefix:
        reboot_subtest = status_map.test_db.get_subtest_by_tag_prefix(
            intentional_reboot_subtest_tag_prefix)
        control_state.run_test(reboot_subtest)
        status_map.read_new_data()

    test = status_map.next_untested()
    while test is not None:
        factory.log('next test = %s' %
                    status_map.test_db.get_unique_details(test))
        if isinstance(test, factory.AutomatedSequence):
            for subtest in test.subtest_list:
                if isinstance(subtest, factory.AutomatedRebootSubTest):
                    tag_prefix = status_map.test_db.get_tag_prefix(subtest)
                    step_reboot_seq(tag_prefix, subtest.iterations)
                else:
                    control_state.run_test(subtest)
                if control_state.activated_kbd_shortcut_test:
                    break
        else:
            control_state.run_test(test)
        status_map.read_new_data()
        test = (control_state.activated_kbd_shortcut_test or
                status_map.next_untested())
