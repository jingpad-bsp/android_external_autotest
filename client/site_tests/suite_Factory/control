# -*- coding: utf-8 -*-
#
# Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

AUTHOR = "Chrome OS Team"
NAME = "Factory"
TIME = "LONG"
TEST_CATEGORY = "Functional"
TEST_CLASS = "suite"
TEST_TYPE = "client"

DOC = """
This suite executed all of the factory tests, and incorporates an
X-windows GTK-based UI to highlight testing results and to allow
factory operators to switch between tests, and to re-run tests, all
on-demand via keyboard shortcuts.

The UI is implemented as a seperate process (see _FACTORY_UI_PATH),
which means that interprocess communication is needed between this
control, the UI, and the tests (which are forked children of this
control process).  """


import imp
import subprocess
import sys
import time

imp.load_source('common', job.autodir + '/bin/common.py')
from autotest_lib.client.bin import factory


_STATUS_FILE_PATH = job.autodir + '/results/default/status'
_FACTORY_UI_PATH = job.autodir + '/bin/factory_ui'


_REBOOT_SEQ_ITERATIONS = 2


# Hack to work around autotest's obsession with GRUB.
job.bootloader.set_default = lambda x: None
job.bootloader.boot_once = lambda x: None


# TEST ORDERING: Tests in the test_list will be run in the order
# below, unless the operator interrupts the flow via keyboard
# shortcut.  To cause immediate execution of the run-in tests, for
# example, reorder runin to occur as the first test in the test_list.

test_list = [
    factory.TestData(
        label_en='start',
        label_zw='開始',
        formal_name='factory_Dummy',
        trigger='e',
        dargs={'quit_key':ord(' '),
               'msg':'Hit SPACE to start testing...\n按 "空白鍵" 開始測試...'}),
    factory.TestData(
        label_en='sync',
        label_zw='同步',
        formal_name='factory_ScriptWrapper',
        trigger='s',
        dargs={'cmdline': job.autodir +
               '/site_tests/factory_ScriptWrapper/dummy.sh'}),
    factory.TestData(
        label_en='run-in',
        label_zw='燒機測試',
        formal_name='step_runin',
        automated_seq=[
            factory.TestData(
                label_en='component validation',
                label_zw='元件驗證',
                formal_name='hardware_Components',
                dargs={'approved_db':'qualified_components'}),
            factory.TestData(
                label_en='gpio switch check',
                label_zw='檢查 gpio 開關',
                formal_name='hardware_GPIOSwitches'),
            factory.TestData(
                label_en='system stress',
                label_zw='壓力測試',
                formal_name='hardware_SAT',
                dargs={'seconds': 60}),
            factory.TestData(
                label_en='graphics',
                label_zw='圖型',
                formal_name='graphics_GLBench'),
            factory.TestData(
                label_en='reboot (%s times)' % _REBOOT_SEQ_ITERATIONS,
                label_zw='重新開機 (%s 次)' % _REBOOT_SEQ_ITERATIONS,
                formal_name='factory_RebootStub')],
        trigger='r'),
    factory.TestData(
        label_en='keyboard',
        label_zw='鍵盤',
        formal_name='factory_Keyboard',
        trigger='k',
        dargs={'layout':'en_us'}),
    factory.TestData(
        label_en='touchpad',
        label_zw='觸控板',
        formal_name='factory_Touchpad',
        trigger='t'),
    factory.TestData(
        label_en='leds',
        label_zw='機身側燈',
        formal_name='factory_Leds',
        trigger='l',
        dargs={'led_ctl_path':
               '/usr/local/autotest/site_tests/factory_Leds/src/ec_ctl'}),
    factory.TestData(
        label_en='display',
        label_zw='顯示',
        formal_name='factory_Display',
        trigger='m'),
    factory.TestData(
        label_en='camera',
        label_zw='相機',
        formal_name='factory_Camera',
        trigger='c'),
    factory.TestData(
        label_en='audio',
        label_zw='聲音',
        formal_name='factory_Dummy',
        trigger='a',
        dargs={'msg':'audio test, one day...'}),
    factory.TestData(
        label_en='hdmi',
        label_zw='',
        formal_name='factory_Dummy',
        trigger='h',
        dargs={'msg':'hdmi test, one day...'}),
    factory.TestData(
        label_en='usb',
        formal_name='factory_ExternalStorage',
        trigger='u',
        dargs={'media':'USB'}),
    factory.TestData(
        label_en='sd',
        formal_name='factory_ExternalStorage',
        trigger='d',
        dargs={'media':'SD'}),
    factory.TestData(
        label_en='bluetooth',
        label_zw='藍芽',
        formal_name='factory_Dummy',
        trigger='o',
        dargs={'msg':'bluetooth test, one day...'}),
    factory.TestData(
        label_en='3g',
        label_zw='3G上網',
        formal_name='factory_Dummy',
        trigger='g',
        dargs={'msg':'3g test, one day...'}),
    factory.TestData(
        label_en='wifi',
        label_zw='無線上網',
        formal_name='factory_Dummy',
        trigger='w',
        dargs={'msg':'wifi test, one day...'}),
    factory.TestData(
        label_en='devrec',
        label_zw='特殊模式',
        formal_name='factory_DeveloperRecovery',
        trigger='b',
        dargs={'layout':'devrec'}),
    factory.TestData(
        label_en='wipe',
        label_zw='清除',
        formal_name='factory_Dummy',
        trigger='x',
        dargs={'msg':('hit TAB+RETURN to write protect FW ' +
                      'and wipe test image!' +
                      '...\n(chinese)...')}),
    factory.TestData(
        label_en='review',
        label_zw='報告',
        formal_name='factory_Review',
        trigger='z'),
]

for test in test_list:
    test.tag_prefix = test.trigger
    for subtest in test.automated_seq:
        subtest.tag_prefix = test.formal_name

test_map = factory.make_test_map(test_list)
trigger_set = factory.make_trigger_set(test_list)


def make_run_subtest(dargs_map):
    return lambda n: job.run_test(n, **dargs_map[n])


def step_reboot_seq(i, run_subtest):
    if i < _REBOOT_SEQ_ITERATIONS:
        job.next_step_prepend([step_reboot_seq, i + 1, run_subtest])
        factory.log('rebooting (iteration %d)' % i)
        time.sleep(5)
        job.reboot()
    else:
        run_subtest('factory_RebootStub')
        step_init()


def step_runin(ui, run_subtest):
    run_subtest('hardware_Components')
    run_subtest('hardware_GPIOSwitches')
    job.drop_caches_between_iterations = True
    run_subtest('hardware_SAT')
    job.drop_caches_between_iterations = False
    run_subtest('graphics_GLBench')
    step_reboot_seq(0, run_subtest)


def step_init():

    '''Launch the factory UI, which will then make decisions on which
    tests to run in which order.  This is to support user driven
    out-of-order test execution based on keyboard shortcuts.

    For each test, a trigger (possibly None) is communicated to the
    UI, which then replies with the test name and a count number that
    becomes the autotest tag to allow repeated test execution while
    preserving logs.

    When the tests themselves run, they are expected to look for
    (using the factory_test library) keyboard events that match test
    switching triggers.  When a trigger happens, it should be written
    to the factory.RESULT_FILE_PATH, which will be read after the test
    completed and the result comminicated onwards to the UI.'''

    job.next_step([step_init])

    ui = factory.UiClient(_FACTORY_UI_PATH)

    ui.send(test_list)
    ui.send(_STATUS_FILE_PATH)

    test_widget_size = ui.recv()
    factory.log('received test_widget_size = %s' % repr(test_widget_size))

    ui.send_cmd_next_test()
    test, test_count = ui.recv_target_test_update(test_map)

    while test is not None:
        if test.automated_seq:
            tag = '%s_%s' % (test.formal_name, test_count)
            dargs_map = dict((st.formal_name, st.dargs)
                             for st in test.automated_seq)
            for i in dargs_map:
                dargs_map[i].update(tag=tag)
            # Why run_subtest needs to be defined in this way is still
            # somewhat mysterious -- basically it does not work any
            # other way, python is maybe doing some lazy evaluation of
            # dargs?  If someone understands this and can write a
            # better comment here, please do.
            run_subtest = make_run_subtest(dargs_map)
            exec('%s(ui, run_subtest)' % (test.formal_name))
            result = None
        else:
            dargs = test.dargs
            dargs.update({
                'tag': '%s_%s' % (test.tag_prefix, test_count),
                'test_tag_prefix': test.tag_prefix,
                'test_count': test_count,
                'test_widget_size': test_widget_size,
                'trigger_set': trigger_set,
                'status_file_path' : _STATUS_FILE_PATH,
                'test_list': test_list})
            with open(factory.RESULT_FILE_PATH, 'w') as file:
                file.write('None\n')
            job.run_test(test.formal_name, **dargs)
            with open(factory.RESULT_FILE_PATH, 'r') as file:
                result = eval(file.readline())

        if result is not None:
            ui.send_cmd_switch_to(result)
        else:
            ui.send_cmd_next_test()

        test, test_count = ui.recv_target_test_update(test_map)

    factory.log('factory testing completed')
